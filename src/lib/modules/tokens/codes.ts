import { prisma } from '@/lib/db/prisma'

const CODE_CHARS = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789' // Removed confusing chars (0, O, I, 1)

/**
 * Generate a unique 5-character redemption code
 */
export async function generateCode(): Promise<string> {
  let attempts = 0
  const maxAttempts = 100

  while (attempts < maxAttempts) {
    let code = ''
    for (let i = 0; i < 5; i++) {
      code += CODE_CHARS.charAt(Math.floor(Math.random() * CODE_CHARS.length))
    }

    // Check if code already exists
    const existing = await prisma.code.findUnique({
      where: { code },
    })

    if (!existing) {
      return code
    }

    attempts++
  }

  throw new Error('Failed to generate unique code after maximum attempts')
}

/**
 * Create a new redemption code
 */
export async function createCode(data: {
  tokens: number
  phoneNumber?: string
  amount?: number
  mpesaReceipt?: string
  createdBy?: string
  autoGenerated?: boolean
}) {
  const code = await generateCode()

  return await prisma.code.create({
    data: {
      code,
      tokens: data.tokens,
      remainingTokens: data.tokens, // Initially, remaining equals total
      phoneNumber: data.phoneNumber,
      amount: data.amount,
      mpesaReceipt: data.mpesaReceipt,
      createdBy: data.createdBy,
      autoGenerated: data.autoGenerated ?? false,
      renderCount: 0,
      usageHistory: [],
    },
  })
}

/**
 * Get code by code string
 */
export async function getCodeByCode(code: string) {
  return await prisma.code.findUnique({
    where: { code: code.toUpperCase() },
  })
}

/**
 * Get all codes
 */
export async function getAllCodes() {
  return await prisma.code.findMany({
    orderBy: { createdAt: 'desc' },
  })
}

/**
 * Create multiple codes at once (bulk generation)
 */
export async function createMultipleCodes(data: {
  tokens: number
  count: number
  createdBy?: string
}): Promise<{ code: string; tokens: number }[]> {
  const results: { code: string; tokens: number }[] = []

  for (let i = 0; i < data.count; i++) {
    const code = await createCode({
      tokens: data.tokens,
      createdBy: data.createdBy,
      autoGenerated: false,
    })
    results.push({ code: code.code, tokens: code.tokens })
  }

  return results
}

/**
 * Revoke a code (soft disable - prevents redemption without deleting)
 */
export async function revokeCode(code: string): Promise<{ success: boolean; msg?: string }> {
  try {
    await prisma.code.update({
      where: { code: code.toUpperCase() },
      data: { isRevoked: true },
    })
    return { success: true }
  } catch (error) {
    return { success: false, msg: 'Code not found' }
  }
}

/**
 * Unrevoke a code (re-enable a revoked code)
 */
export async function unrevokeCode(code: string): Promise<{ success: boolean; msg?: string }> {
  try {
    await prisma.code.update({
      where: { code: code.toUpperCase() },
      data: { isRevoked: false },
    })
    return { success: true }
  } catch (error) {
    return { success: false, msg: 'Code not found' }
  }
}

/**
 * Get codes by phone number
 */
export async function getCodesByPhone(phoneNumber: string) {
  return await prisma.code.findMany({
    where: { phoneNumber },
    orderBy: { createdAt: 'desc' },
  })
}

/**
 * Redeem a code for a user
 * Returns the number of tokens added
 * Uses transactions for atomic updates to handle concurrent redemptions
 */
export async function redeemCode(code: string, userId: string): Promise<{
  success: boolean
  tokens: number
  remainingTokens: number
  alreadyRedeemed: boolean
  msg?: string
}> {
  const codeUpper = code.toUpperCase()

  // Use transaction for atomic operations
  return await prisma.$transaction(async (tx) => {
    // Get code from database with lock for update
    const codeData = await tx.code.findUnique({
      where: { code: codeUpper },
    })

    if (!codeData) {
      return {
        success: false,
        tokens: 0,
        remainingTokens: 0,
        alreadyRedeemed: false,
        msg: 'Code does not exist or code invalid try again.',
      }
    }

    // Check if code is revoked
    if ((codeData as any).isRevoked) {
      return {
        success: false,
        tokens: 0,
        remainingTokens: codeData.remainingTokens,
        alreadyRedeemed: false,
        msg: 'This code has been revoked and cannot be used.',
      }
    }

    // Check if code has remaining tokens
    if (codeData.remainingTokens <= 0) {
      return {
        success: false,
        tokens: 0,
        remainingTokens: 0,
        alreadyRedeemed: false,
        msg: 'Code has been fully used.',
      }
    }

    // Get or create user token record
    let userToken = await tx.userToken.findUnique({
      where: { userId },
    })

    if (!userToken) {
      userToken = await tx.userToken.create({
        data: {
          userId,
          totalTokens: 0,
          usedTokens: 0,
          balance: 0,
          redeemedCodes: [],
        },
      })
    }

    // Redeem all available tokens from the code
    const tokensToAdd = codeData.remainingTokens

    // Atomic: Check remaining tokens again and decrement
    if (codeData.remainingTokens < tokensToAdd) {
      return {
        success: false,
        tokens: 0,
        remainingTokens: codeData.remainingTokens,
        alreadyRedeemed: false,
        msg: 'Not enough tokens remaining in this code.',
      }
    }

    // Track code usage for this user (for history purposes, not blocking)
    const redeemedCodes = (userToken.redeemedCodes as string[]) || []
    const updatedRedeemedCodes = redeemedCodes.includes(codeUpper)
      ? redeemedCodes
      : [...redeemedCodes, codeUpper]

    // Update user tokens atomically
    await tx.userToken.update({
      where: { userId },
      data: {
        totalTokens: { increment: tokensToAdd },
        balance: { increment: tokensToAdd },
        redeemedCodes: updatedRedeemedCodes,
      },
    })

    // Update code usage atomically with decrement
    const updatedUsageHistory = (codeData.usageHistory as any[]) || []
    updatedUsageHistory.push({
      userId,
      timestamp: new Date().toISOString(),
      tokensAdded: tokensToAdd,
    })

    const updatedCode = await tx.code.update({
      where: { code: codeUpper },
      data: {
        renderCount: { increment: 1 },
        remainingTokens: { decrement: tokensToAdd },
        usageHistory: updatedUsageHistory,
      },
    })

    // Record in usage history table
    await tx.codeUsageHistory.create({
      data: {
        codeId: codeData.id,
        userId,
        tokensUsed: tokensToAdd,
      },
    })

    return {
      success: true,
      tokens: tokensToAdd,
      remainingTokens: updatedCode.remainingTokens,
      alreadyRedeemed: false,
    }
  }, {
    isolationLevel: 'Serializable', // Highest isolation to prevent race conditions
  })
}

/**
 * Delete a code
 */
export async function deleteCode(code: string) {
  return await prisma.code.delete({
    where: { code: code.toUpperCase() },
  })
}

