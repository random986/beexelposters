import { NextRequest, NextResponse } from 'next/server'
import { requireAdmin } from '@/lib/modules/auth/session'
import { prisma } from '@/lib/db/prisma'
import { createErrorResponse } from '@/lib/utils/errors'

export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'
export const revalidate = 0

// Profit per token (KES) - 1 token = KES 8 profit
const PROFIT_PER_TOKEN = 8

export async function GET() {
  // Skip during build time
  if (process.env.NEXT_PHASE === 'phase-production-build') {
    return NextResponse.json({
      success: false,
      msg: 'Not available during build',
    }, { status: 503 })
  }

  try {
    await requireAdmin()

    // ==========================================
    // TRANSACTIONS & REVENUE
    // ==========================================
    const allTransactions = await prisma.transaction.findMany()

    const completedTransactions = allTransactions.filter(tx =>
      tx.status?.toLowerCase() === 'completed' || tx.status?.toLowerCase() === 'complete'
    )
    const pendingTransactions = allTransactions.filter(tx =>
      tx.status?.toLowerCase() === 'pending' || tx.status?.toLowerCase() === 'processing'
    )
    const failedTransactions = allTransactions.filter(tx =>
      tx.status?.toLowerCase() === 'failed'
    )

    const totalRevenue = completedTransactions.reduce((sum: number, tx) => sum + Number(tx.amount), 0)
    const tokensSold = completedTransactions.reduce((sum: number, tx) => sum + (tx.tokens || 0), 0)

    // ==========================================
    // RENDER JOBS & PROFIT CALCULATION
    // ==========================================
    const allJobs = await prisma.job.findMany({
      select: {
        id: true,
        resolution: true,
        status: true,
        createdAt: true,
      }
    })

    const successfulJobs = allJobs.filter(job => job.status === 'success')
    const failedJobs = allJobs.filter(job => job.status === 'failed')
    const pendingJobs = allJobs.filter(job => job.status === 'pending' || job.status === 'processing')

    // Count 4K vs standard renders
    const jobs4K = successfulJobs.filter(job => job.resolution?.toLowerCase() === '4k')
    const jobsStandard = successfulJobs.filter(job => job.resolution?.toLowerCase() !== '4k')

    // Calculate tokens used from successful renders
    const tokens4K = jobs4K.length * 2  // 4K uses 2 tokens
    const tokensStandard = jobsStandard.length * 1  // Standard uses 1 token
    const totalTokensUsed = tokens4K + tokensStandard

    // Calculate PROFIT - Only from PAID tokens (not free giveaways)
    // Profit = tokens sold Ã— KES 8 per token
    const totalProfit = tokensSold * PROFIT_PER_TOKEN

    // Realized profit = profit from tokens that have been used (capped at total sold)
    // Can't realize more profit than what was sold
    const realizedTokens = Math.min(totalTokensUsed, tokensSold)
    const realizedProfit = realizedTokens * PROFIT_PER_TOKEN

    // Unrealized profit = tokens sold but not yet used
    const unrealizedProfit = Math.max(0, totalProfit - realizedProfit)

    // Calculate tokens remaining across all users
    const userTokenAggregates = await prisma.userToken.aggregate({
      _sum: {
        balance: true,
        totalTokens: true,
        usedTokens: true,
      }
    })

    const tokensRemaining = userTokenAggregates._sum.balance || 0

    // ==========================================
    // USERS
    // ==========================================
    const totalUsers = await prisma.userToken.count()
    const activeUsers = await prisma.activeUser.count({
      where: {
        lastSeen: {
          gte: new Date(Date.now() - 30 * 60 * 1000), // Last 30 minutes
        },
      },
    })

    // Users who have made at least one render
    const usersWithRenders = await prisma.job.groupBy({
      by: ['userId'],
      _count: true,
    })
    const renderingUsers = usersWithRenders.length

    // ==========================================
    // CODES - Distinguish PAID vs FREE
    // ==========================================
    const allCodes = await prisma.code.findMany({
      select: {
        id: true,
        tokens: true,
        remainingTokens: true,
        amount: true,
        autoGenerated: true,
      }
    })

    const totalCodes = allCodes.length
    const exhaustedCodes = allCodes.filter(c => c.remainingTokens === 0).length
    const activeCodes = totalCodes - exhaustedCodes

    // PAID codes = have amount OR are autoGenerated (from payment)
    const paidCodes = allCodes.filter(c => c.amount !== null || c.autoGenerated === true)
    // FREE codes = no amount AND not autoGenerated (admin-created giveaways)
    const freeCodes = allCodes.filter(c => c.amount === null && c.autoGenerated === false)

    // Tokens from PAID sources (generates profit)
    const paidTokensIssued = paidCodes.reduce((sum, c) => sum + c.tokens, 0)
    const paidTokensRemaining = paidCodes.reduce((sum, c) => sum + c.remainingTokens, 0)
    const paidTokensUsed = paidTokensIssued - paidTokensRemaining

    // Tokens from FREE sources (no profit)
    const freeTokensIssued = freeCodes.reduce((sum, c) => sum + c.tokens, 0)
    const freeTokensRemaining = freeCodes.reduce((sum, c) => sum + c.remainingTokens, 0)
    const freeTokensUsed = freeTokensIssued - freeTokensRemaining

    // Total tokens
    const tokensIssuedViaCodes = paidTokensIssued + freeTokensIssued
    const tokensRemainingInCodes = paidTokensRemaining + freeTokensRemaining
    const tokensRedeemedFromCodes = tokensIssuedViaCodes - tokensRemainingInCodes

    // ==========================================
    // CONVERSION & PERFORMANCE METRICS
    // ==========================================
    const conversionRate = allTransactions.length > 0
      ? ((completedTransactions.length / allTransactions.length) * 100).toFixed(1)
      : '0'

    const renderSuccessRate = allJobs.length > 0
      ? ((successfulJobs.length / allJobs.length) * 100).toFixed(1)
      : '0'

    const avgRendersPerUser = renderingUsers > 0
      ? (successfulJobs.length / renderingUsers).toFixed(1)
      : '0'

    // Token efficiency (tokens used vs tokens sold)
    const tokenUtilization = tokensSold > 0
      ? ((totalTokensUsed / tokensSold) * 100).toFixed(1)
      : '0'

    return NextResponse.json({
      success: true,
      analytics: {
        revenue: {
          total: totalRevenue,
          transactions: completedTransactions.length,
          tokensSold,
        },
        profit: {
          total: totalProfit,
          realized: realizedProfit,
          unrealized: unrealizedProfit,
          perTokenRate: PROFIT_PER_TOKEN,
        },
        renders: {
          total: allJobs.length,
          successful: successfulJobs.length,
          failed: failedJobs.length,
          pending: pendingJobs.length,
          jobs4K: jobs4K.length,
          jobsStandard: jobsStandard.length,
        },
        tokens: {
          sold: tokensSold,
          used: totalTokensUsed,
          remaining: tokensRemaining,
          tokens4K,
          tokensStandard,
          issuedViaCodes: tokensIssuedViaCodes,
          redeemedFromCodes: tokensRedeemedFromCodes,
          // Paid vs Free breakdown
          paidIssued: paidTokensIssued,
          paidUsed: paidTokensUsed,
          freeIssued: freeTokensIssued,
          freeUsed: freeTokensUsed,
        },
        payments: {
          completed: completedTransactions.length,
          pending: pendingTransactions.length,
          failed: failedTransactions.length,
          total: allTransactions.length,
        },
        users: {
          total: totalUsers,
          active: activeUsers,
          withRenders: renderingUsers,
        },
        codes: {
          total: totalCodes,
          exhausted: exhaustedCodes,
          active: activeCodes,
          paid: paidCodes.length,
          free: freeCodes.length,
        },
        performance: {
          paymentConversionRate: `${conversionRate}%`,
          renderSuccessRate: `${renderSuccessRate}%`,
          avgRendersPerUser: avgRendersPerUser,
          tokenUtilization: `${tokenUtilization}%`,
        },
      },
    })
  } catch (error) {
    console.error('[API] Get analytics error:', error)
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({
        success: false,
        msg: 'Unauthorized',
      }, { status: 401 })
    }
    return NextResponse.json(createErrorResponse(error), { status: 500 })
  }
}
