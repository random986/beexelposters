/**
 * Migration script to move data from SQLite to PostgreSQL
 * Run: node scripts/migrate-data.js
 */

const sqlite3 = require('sqlite3').verbose()
const { PrismaClient } = require('@prisma/client')
const path = require('path')

const sqliteDbPath = path.join(__dirname, '..', '..', 'database', 'portal.db')
const prisma = new PrismaClient()

async function migrateData() {
  console.log('Starting data migration from SQLite to PostgreSQL...')

  // Open SQLite database
  const sqliteDb = new sqlite3.Database(sqliteDbPath, (err) => {
    if (err) {
      console.error('Error opening SQLite database:', err)
      process.exit(1)
    }
  })

  try {
    // Migrate Codes
    console.log('Migrating codes...')
    const codes = await new Promise((resolve, reject) => {
      sqliteDb.all('SELECT * FROM codes', [], (err, rows) => {
        if (err) reject(err)
        else resolve(rows)
      })
    })

    for (const code of codes) {
      try {
        await prisma.code.create({
          data: {
            code: code.code,
            tokens: code.tokens || 0,
            remainingTokens: code.remaining_tokens || 0,
            phoneNumber: code.phone_number,
            amount: code.amount,
            mpesaReceipt: code.mpesa_receipt_number,
            createdAt: new Date(code.created_at),
            createdBy: code.created_by,
            autoGenerated: code.auto_generated === 1,
            renderCount: code.render_count || 0,
            usageHistory: code.usage_history ? JSON.parse(code.usage_history) : [],
          },
        })
      } catch (err) {
        console.warn(`Skipping code ${code.code}:`, err.message)
      }
    }
    console.log(`Migrated ${codes.length} codes`)

    // Migrate User Tokens
    console.log('Migrating user tokens...')
    const userTokens = await new Promise((resolve, reject) => {
      sqliteDb.all('SELECT * FROM user_tokens', [], (err, rows) => {
        if (err) reject(err)
        else resolve(rows)
      })
    })

    for (const ut of userTokens) {
      try {
        await prisma.userToken.create({
          data: {
            userId: ut.user_id,
            totalTokens: ut.total_tokens || 0,
            usedTokens: ut.used_tokens || 0,
            balance: ut.balance || 0,
            transactions: ut.transactions ? JSON.parse(ut.transactions) : [],
            redeemedCodes: ut.redeemed_codes ? JSON.parse(ut.redeemed_codes) : [],
            createdAt: new Date(ut.created_at),
            updatedAt: new Date(ut.updated_at || ut.created_at),
          },
        })
      } catch (err) {
        console.warn(`Skipping user token ${ut.user_id}:`, err.message)
      }
    }
    console.log(`Migrated ${userTokens.length} user tokens`)

    // Migrate Transactions
    console.log('Migrating transactions...')
    const transactions = await new Promise((resolve, reject) => {
      sqliteDb.all('SELECT * FROM transactions', [], (err, rows) => {
        if (err) reject(err)
        else resolve(rows)
      })
    })

    for (const tx of transactions) {
      try {
        await prisma.transaction.create({
          data: {
            id: tx.id,
            invoiceId: tx.invoice_id,
            amount: tx.amount,
            mpesaNumber: tx.mpesa_number,
            email: tx.email,
            userId: tx.user_id,
            tokens: tx.tokens,
            status: tx.status || 'pending',
            mpesaReceipt: tx.mpesa_receipt_number,
            stkRequestId: tx.stk_request_id,
            apiRef: tx.api_ref,
            createdAt: new Date(tx.created_at),
            completedAt: tx.completed_at ? new Date(tx.completed_at) : null,
            paymentReceivedAt: tx.payment_received_at ? new Date(tx.payment_received_at) : null,
            lastCheckedAt: tx.last_checked_at ? new Date(tx.last_checked_at) : null,
            codeGeneratedAt: tx.code_generated_at ? new Date(tx.code_generated_at) : null,
            codeGeneratedBy: tx.code_generated_by,
          },
        })
      } catch (err) {
        console.warn(`Skipping transaction ${tx.id}:`, err.message)
      }
    }
    console.log(`Migrated ${transactions.length} transactions`)

    // Migrate Jobs
    console.log('Migrating jobs...')
    const jobs = await new Promise((resolve, reject) => {
      sqliteDb.all('SELECT * FROM jobs', [], (err, rows) => {
        if (err) reject(err)
        else resolve(rows)
      })
    })

    for (const job of jobs) {
      try {
        await prisma.job.create({
          data: {
            id: job.id,
            taskId: job.task_id,
            userId: job.user_id,
            prompt: job.prompt,
            enhancedPrompt: job.enhanced_prompt,
            aspect: job.aspect,
            resolution: job.resolution,
            mode: job.mode,
            denoise: job.denoise,
            seed: job.seed,
            treeGroup: job.tree_group,
            uploadedImage: job.uploaded_image,
            status: job.status || 'pending',
            resultUrls: job.result_urls ? JSON.parse(job.result_urls) : null,
            apiResponse: job.api_response ? JSON.parse(job.api_response) : null,
            apiResult: job.api_result ? JSON.parse(job.api_result) : null,
            errorMessage: job.error_message,
            createdAt: new Date(job.created_at),
            updatedAt: new Date(job.updated_at || job.created_at),
          },
        })
      } catch (err) {
        console.warn(`Skipping job ${job.id}:`, err.message)
      }
    }
    console.log(`Migrated ${jobs.length} jobs`)

    console.log('âœ… Migration completed successfully!')
  } catch (error) {
    console.error('Migration error:', error)
    process.exit(1)
  } finally {
    sqliteDb.close()
    await prisma.$disconnect()
  }
}

migrateData()



